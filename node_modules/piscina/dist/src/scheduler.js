"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DefaultTaskScheduler_pendingItems, _DefaultTaskScheduler_readyItems, _DefaultTaskScheduler_maximumUsage, _DefaultTaskScheduler_onAvailableListeners;
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTaskSchedulerLike = exports.DefaultTaskScheduler = exports.TaskScheduler = void 0;
function isTaskSchedulerLike(obj) {
    if (Object.getPrototypeOf(obj) === TaskScheduler)
        return true;
    const keys = [
        'onWorkerAvailable',
        'onAvailable',
        'pick',
        'delete',
        'size'
    ];
    for (const key of keys) {
        if (!(key in obj))
            return false;
    }
    return true;
}
exports.isTaskSchedulerLike = isTaskSchedulerLike;
class TaskScheduler {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    constructor(_concurrentTasksPerWorker) {
        this.size = 0;
    }
    [Symbol.iterator]() {
        throw new Error('Iterator not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    add(_worker) {
        throw new Error('add Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    pick(_task, _runOptions) {
        throw new Error('pick Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAvailable(_cb) {
        throw new Error('onAvailable Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    delete(_worker) {
        throw new Error('delete Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onWorkerAvailable(_worker) {
        throw new Error('onNewWorker Method not implemented.');
    }
    getAvailableCapacity() {
        throw new Error('getAvailableCapacity Method not implemented.');
    }
}
exports.TaskScheduler = TaskScheduler;
class DefaultTaskScheduler extends TaskScheduler {
    constructor(maximumUsage) {
        super(maximumUsage);
        _DefaultTaskScheduler_pendingItems.set(this, new Set());
        _DefaultTaskScheduler_readyItems.set(this, new Set());
        _DefaultTaskScheduler_maximumUsage.set(this, void 0);
        _DefaultTaskScheduler_onAvailableListeners.set(this, void 0);
        __classPrivateFieldSet(this, _DefaultTaskScheduler_maximumUsage, maximumUsage, "f");
        __classPrivateFieldSet(this, _DefaultTaskScheduler_onAvailableListeners, [], "f");
    }
    add(item) {
        __classPrivateFieldGet(this, _DefaultTaskScheduler_pendingItems, "f").add(item);
        item.onReady(() => {
            /* istanbul ignore else */
            if (__classPrivateFieldGet(this, _DefaultTaskScheduler_pendingItems, "f").has(item)) {
                __classPrivateFieldGet(this, _DefaultTaskScheduler_pendingItems, "f").delete(item);
                __classPrivateFieldGet(this, _DefaultTaskScheduler_readyItems, "f").add(item);
                this.onWorkerAvailable(item);
            }
        });
    }
    delete(item) {
        __classPrivateFieldGet(this, _DefaultTaskScheduler_pendingItems, "f").delete(item);
        __classPrivateFieldGet(this, _DefaultTaskScheduler_readyItems, "f").delete(item);
    }
    pick(_task, opts) {
        let minUsage = __classPrivateFieldGet(this, _DefaultTaskScheduler_maximumUsage, "f");
        let candidate = null;
        for (const item of __classPrivateFieldGet(this, _DefaultTaskScheduler_readyItems, "f")) {
            const usage = item.currentUsage();
            if (usage === 0) {
                return item;
            }
            ;
            // If we want the ability to abort this task, use only workers that have
            // no running tasks.
            if (opts.signal == null && usage < minUsage) {
                candidate = item;
                minUsage = usage;
            }
        }
        return candidate;
    }
    *[(_DefaultTaskScheduler_pendingItems = new WeakMap(), _DefaultTaskScheduler_readyItems = new WeakMap(), _DefaultTaskScheduler_maximumUsage = new WeakMap(), _DefaultTaskScheduler_onAvailableListeners = new WeakMap(), Symbol.iterator)]() {
        yield* __classPrivateFieldGet(this, _DefaultTaskScheduler_pendingItems, "f");
        yield* __classPrivateFieldGet(this, _DefaultTaskScheduler_readyItems, "f");
    }
    // @ts-expect-error
    get size() {
        return __classPrivateFieldGet(this, _DefaultTaskScheduler_pendingItems, "f").size + __classPrivateFieldGet(this, _DefaultTaskScheduler_readyItems, "f").size;
    }
    set size(_value) {
        // no-op
    }
    onWorkerAvailable(item) {
        /* istanbul ignore else */
        if (item.currentUsage() < __classPrivateFieldGet(this, _DefaultTaskScheduler_maximumUsage, "f")) {
            for (const listener of __classPrivateFieldGet(this, _DefaultTaskScheduler_onAvailableListeners, "f")) {
                listener(item);
            }
        }
    }
    onAvailable(fn) {
        __classPrivateFieldGet(this, _DefaultTaskScheduler_onAvailableListeners, "f").push(fn);
    }
    getAvailableCapacity() {
        return __classPrivateFieldGet(this, _DefaultTaskScheduler_pendingItems, "f").size * __classPrivateFieldGet(this, _DefaultTaskScheduler_maximumUsage, "f");
    }
}
exports.DefaultTaskScheduler = DefaultTaskScheduler;
//# sourceMappingURL=scheduler.js.map